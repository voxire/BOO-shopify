{%- liquid
  assign section_id = section.id
  assign heading = section.settings.heading
  assign subheading = section.settings.subheading
  assign alignment = section.settings.alignment
  assign heading_size = section.settings.heading_size | default: 24
  assign heading_color = section.settings.heading_color
  assign card_radius = section.settings.card_radius | default: 18
  assign card_bottom_radius = section.settings.card_bottom_radius | default: 18
  assign card_width = section.settings.card_width
  assign gap = section.settings.gap | default: 20
  assign show_arrows = section.settings.show_arrows
  assign show_dots = section.settings.show_dots
  assign autoplay = section.settings.autoplay
  assign autoplay_seconds = section.settings.autoplay_seconds | default: 5
  assign show_vendor = section.settings.show_vendor
  assign show_color_swatches = section.settings.show_color_swatches
  assign card_content_bg_color = section.settings.card_content_bg_color
  assign card_content_text_color = section.settings.card_content_text_color
  assign card_content_border_color = section.settings.card_content_border_color
  assign card_content_border_width = section.settings.card_content_border_width | default: 0
  assign card_content_border_radius = section.settings.card_content_border_radius | default: 0
  assign card_content_padding = section.settings.card_content_padding | default: 24
  assign card_content_margin = section.settings.card_content_margin | default: 0
  assign item_blocks = section.blocks | where: 'type', 'product'
-%}

<section
  id="CenterProductCarousel-{{ section_id }}"
  class="cpc-section cpc-section--{{ section_id }}"
  data-section-id="{{ section_id }}"
  data-autoplay="{{ autoplay }}"
  data-autoplay-delay="{{ autoplay_seconds }}"
  data-loop="true"
  style="--cpc-gap: {{ gap }}px; --cpc-card-radius: {{ card_radius }}px; --cpc-card-bottom-radius: {{ card_bottom_radius }}px;{% if card_width != blank %} --cpc-card-width: {{ card_width }}px;{% endif %} --cpc-autoplay-delay: {{ autoplay_seconds }}s; --cpc-heading-size: {{ heading_size }}px;{% if heading_color != blank %} --cpc-heading-color: {{ heading_color }};{% endif %}{% if card_content_bg_color != blank %} --cpc-card-content-bg: {{ card_content_bg_color }};{% endif %}{% if card_content_text_color != blank %} --cpc-card-content-text: {{ card_content_text_color }};{% endif %}{% if card_content_border_color != blank %} --cpc-card-content-border-color: {{ card_content_border_color }};{% endif %} --cpc-card-content-border-width: {{ card_content_border_width }}px; --cpc-card-content-border-radius: {{ card_content_border_radius }}px; --cpc-card-content-padding: {{ card_content_padding }}px; --cpc-card-content-margin: {{ card_content_margin }}px;"
>
  <div class="cpc-container">
    {%- if heading != blank or subheading != blank -%}
      <div class="cpc-header cpc-header--{{ alignment }}">
        {%- if heading != blank -%}
          <h2 class="cpc-heading">{{ heading }}</h2>
        {%- endif -%}
        {%- if subheading != blank -%}
          <p class="cpc-subheading">{{ subheading }}</p>
        {%- endif -%}
      </div>
    {%- endif -%}

    {%- if item_blocks.size > 0 -%}
      <div class="cpc-carousel-wrapper">
        <div class="cpc-viewport" data-viewport>
          <div class="cpc-track" data-track>
            {%- for block in item_blocks -%}
              {%- assign product = block.settings.product -%}
              {%- if product != blank -%}
                <div class="cpc-slide{% if forloop.first %} is-active{% endif %}" {{ block.shopify_attributes }} data-slide-index="{{ forloop.index0 }}">
                <div class="cpc-card">
                  <div class="cpc-media-tile">
                    {%- liquid
                      assign media_source = block.settings.media_source | default: 'product_featured'
                      assign focal_position = block.settings.focal_position | default: 'center'
                      assign object_position = 'center'
                      if focal_position == 'top'
                        assign object_position = 'top center'
                      elsif focal_position == 'bottom'
                        assign object_position = 'bottom center'
                      endif
                    -%}

                    {%- if block.settings.badge_text != blank -%}
                      <div class="cpc-badge">{{ block.settings.badge_text }}</div>
                    {%- endif -%}

                    {%- if media_source == 'external_gif_url' and block.settings.external_gif_url != blank -%}
                      {%- liquid
                        assign placeholder_url = block.settings.placeholder_image | image_url: width: 1200
                        if placeholder_url == blank and product.featured_media != blank
                          assign placeholder_url = product.featured_media | image_url: width: 1200
                        endif
                        if placeholder_url == blank
                          assign placeholder_url = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
                        endif
                      -%}
                      <img
                        draggable="false"
                        data-gif-url="{{ block.settings.external_gif_url }}"
                        data-placeholder-url="{{ placeholder_url }}"
                        {% if forloop.first %}src="{{ block.settings.external_gif_url }}"{% else %}src="{{ placeholder_url }}"{% endif %}
                        alt="{{ block.settings.alt_text | default: product.title | escape }}"
                        class="cpc-card-image cpc-gif-image"
                        style="object-position: {{ object_position }};"
                        {% unless forloop.first %}loading="lazy"{% endunless %}
                      >
                    {%- elsif media_source == 'custom_image_or_gif' and block.settings.custom_media != blank -%}
                      {%- liquid
                        assign media_url = block.settings.custom_media | image_url: width: 1200
                        assign is_gif = false
                        if block.settings.custom_media.alt contains '.gif' or media_url contains '.gif'
                          assign is_gif = true
                        endif
                      -%}
                      {%- if is_gif -%}
                        {%- liquid
                          assign placeholder_url = block.settings.placeholder_image | image_url: width: 1200
                          if placeholder_url == blank and product.featured_media != blank
                            assign placeholder_url = product.featured_media | image_url: width: 1200
                          endif
                          if placeholder_url == blank
                            assign placeholder_url = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
                          endif
                        -%}
                        <img
                          draggable="false"
                          data-gif-url="{{ media_url }}"
                          data-placeholder-url="{{ placeholder_url }}"
                          {% if forloop.first %}src="{{ media_url }}"{% else %}src="{{ placeholder_url }}"{% endif %}
                          alt="{{ block.settings.alt_text | default: product.title | escape }}"
                          class="cpc-card-image cpc-gif-image"
                          style="object-position: {{ object_position }};"
                          {% unless forloop.first %}loading="lazy"{% endunless %}
                        >
                      {%- else -%}
                        <img
                          draggable="false"
                          src="{{ media_url }}"
                          alt="{{ block.settings.alt_text | default: product.title | escape }}"
                          class="cpc-card-image"
                          style="object-position: {{ object_position }};"
                          {% unless forloop.first %}loading="lazy"{% endunless %}
                        >
                      {%- endif -%}
                    {%- elsif product.featured_media != blank -%}
                      <img
                        draggable="false"
                        src="{{ product.featured_media | image_url: width: 1200 }}"
                        srcset="{{ product.featured_media | image_url: width: 300 }} 300w,
                                {{ product.featured_media | image_url: width: 600 }} 600w,
                                {{ product.featured_media | image_url: width: 900 }} 900w,
                                {{ product.featured_media | image_url: width: 1200 }} 1200w"
                        sizes="(max-width: 749px) 85vw, 400px"
                        alt="{{ block.settings.alt_text | default: product.featured_media.alt | default: product.title | escape }}"
                        class="cpc-card-image"
                        style="object-position: {{ object_position }};"
                        {% unless forloop.first %}loading="lazy"{% endunless %}
                        width="{{ product.featured_media.width }}"
                        height="{{ product.featured_media.height }}"
                      >
                    {%- else -%}
                      <div class="cpc-card-placeholder">
                        {{ 'product-1' | placeholder_svg_tag: 'cpc-placeholder-svg' }}
                      </div>
                    {%- endif -%}
                  </div>

                  <a href="{{ product.url }}" class="cpc-info-card" draggable="false">
                    <div class="cpc-info-thumb">
                      {%- if product.featured_media != blank -%}
                        <img
                          draggable="false"
                          src="{{ product.featured_media | image_url: width: 120 }}"
                          alt="{{ product.featured_media.alt | default: product.title | escape }}"
                          class="cpc-info-thumb-image"
                          {% unless forloop.first %}loading="lazy"{% endunless %}
                          width="120"
                          height="120"
                        >
                      {%- else -%}
                        <div class="cpc-info-thumb-placeholder">
                          {{ 'product-1' | placeholder_svg_tag: 'cpc-info-thumb-placeholder-svg' }}
                        </div>
                      {%- endif -%}
                    </div>
                    
                    <div class="cpc-info-text">
                      <h3 class="cpc-info-title">{{ product.title }}</h3>
                      <div class="cpc-info-price">
                        {%- assign variant = product.selected_or_first_available_variant -%}
                        {%- if variant.compare_at_price > variant.price -%}
                          <span class="cpc-price-compare">{{ variant.compare_at_price | money }}</span>
                        {%- endif -%}
                        <span class="cpc-price-current">{{ variant.price | money }}</span>
                      </div>
                    </div>

                    <div class="cpc-info-caret">
                      <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <path d="M6 12L10 8L6 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
                      </svg>
                    </div>
                  </a>
                </div>
                </div>
              {%- endif -%}
            {%- endfor -%}
          </div>
        </div>
      </div>
    {%- else -%}
      <div class="cpc-empty">
        <p>{{ 'sections.collection_template.empty' | t | default: 'Add products to this carousel' }}</p>
      </div>
    {%- endif -%}
  </div>
</section>

<style>
  /* Center Product Carousel Styles */
  .cpc-section--{{ section_id }} {
    padding: 4rem 0;
    position: relative;
  }

  .cpc-section--{{ section_id }} .cpc-container {
    max-width: var(--page-width, 120rem);
    margin: 0 auto;
    padding: 0 1.5rem;
  }

  .cpc-section--{{ section_id }} .cpc-header {
    margin-bottom: 3rem;
    text-align: {{ alignment }};
  }

  .cpc-section--{{ section_id }} .cpc-heading {
    font-size: var(--cpc-heading-size, 2.4rem);
    font-weight: 600;
    margin: 0 0 1rem;
    line-height: 1.2;
    {%- if heading_color != blank -%}
      color: var(--cpc-heading-color);
    {%- endif -%}
  }

  .cpc-section--{{ section_id }} .cpc-subheading {
    font-size: 1.6rem;
    color: rgba(var(--color-foreground), 0.7);
    margin: 0;
    line-height: 1.5;
  }

  .cpc-section--{{ section_id }} .cpc-carousel-wrapper {
    position: relative;
    padding: 0 4rem;
  }

  @media screen and (max-width: 749px) {
    .cpc-section--{{ section_id }} .cpc-carousel-wrapper {
      padding: 0 3rem;
    }
  }

  .cpc-section--{{ section_id }} .cpc-viewport {
    overflow: hidden;
  }

  .cpc-section--{{ section_id }} .cpc-track {
    display: flex;
    overflow-x: auto;
    overflow-y: hidden;
    -webkit-overflow-scrolling: touch;
    scroll-behavior: auto;
    gap: var(--cpc-gap);
    padding: 0;
    scrollbar-width: none;
    -ms-overflow-style: none;
    scroll-snap-type: x mandatory;
    contain: layout style paint;
  }

  .cpc-section--{{ section_id }} .cpc-track::-webkit-scrollbar {
    display: none;
  }

  .cpc-section--{{ section_id }} .cpc-track.is-dragging {
    scroll-snap-type: none !important;
    scroll-behavior: auto !important;
    cursor: grabbing;
  }

  .cpc-section--{{ section_id }} .cpc-track.is-dragging .cpc-slide {
    transition: transform 120ms ease, opacity 120ms ease;
  }

  .cpc-section--{{ section_id }} .cpc-track.is-dragging .cpc-card-image {
    transition: transform 120ms ease;
  }

  .cpc-section--{{ section_id }} .cpc-slide {
    min-width: 0;
    flex: 0 0 100%;
    scroll-snap-align: center;
    scroll-snap-stop: always;
    transform-origin: center;
    transition: transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94), opacity 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    opacity: 0.88;
    transform: scale(0.95);
    will-change: transform, opacity;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }

  @media screen and (min-width: 750px) {
    .cpc-section--{{ section_id }} .cpc-slide {
      flex: 0 0 calc((100% - var(--cpc-gap)) / 2);
    }
  }

  @media screen and (min-width: 990px) {
    .cpc-section--{{ section_id }} .cpc-slide {
      flex: 0 0 calc((100% - (var(--cpc-gap) * 2)) / 3);
    }
  }

  .cpc-section--{{ section_id }} .cpc-slide.is-active {
    opacity: 1;
    transform: scale(1);
    z-index: 2;
  }

  .cpc-section--{{ section_id }} .cpc-card {
    display: flex;
    flex-direction: column;
    height: 100%;
    background: transparent;
    max-width: var(--cpc-card-width, 100%);
    width: 100%;
    position: relative;
    z-index: 1;
  }

  .cpc-section--{{ section_id }} .cpc-media-tile {
    position: relative;
    width: 100%;
    aspect-ratio: 3 / 4;
    overflow: hidden;
    background: rgba(var(--color-foreground), 0.03);
    border-radius: var(--cpc-card-radius);
    box-shadow: 0 4px 16px rgba(var(--color-foreground), 0.08);
    transition: box-shadow 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  .cpc-section--{{ section_id }} .cpc-slide.is-active .cpc-media-tile {
    box-shadow: 0 8px 24px rgba(var(--color-foreground), 0.12);
  }

  .cpc-section--{{ section_id }} .cpc-badge {
    position: absolute;
    top: 1.2rem;
    left: 1.2rem;
    background: rgba(var(--color-button), 1);
    color: rgba(var(--color-button-text), 1);
    padding: 0.6rem 1.2rem;
    border-radius: 2rem;
    font-size: 1.2rem;
    font-weight: 600;
    z-index: 2;
  }

  .cpc-section--{{ section_id }} .cpc-card-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: center;
    display: block;
    transition: transform 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    will-change: transform;
    backface-visibility: hidden;
    -webkit-backface-visibility: hidden;
  }

  .cpc-section--{{ section_id }} .cpc-slide.is-active .cpc-card-image {
    transform: scale(1.02);
  }

  .cpc-section--{{ section_id }} .cpc-card-placeholder {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    background: rgba(var(--color-foreground), 0.03);
  }

  .cpc-section--{{ section_id }} .cpc-info-card {
    display: flex;
    align-items: center;
    gap: 1.2rem;
    width: calc(100% - 2.4rem);
    margin-left: 1.2rem;
    margin-right: 1.2rem;
    margin-top: -1.8rem;
    padding: var(--cpc-card-content-padding, 1.2rem);
    background: var(--cpc-card-content-bg, rgba(var(--color-background), 1));
    color: var(--cpc-card-content-text, rgba(var(--color-foreground), 1));
    {%- if card_content_border_width > 0 -%}
      border: var(--cpc-card-content-border-width) solid var(--cpc-card-content-border-color, rgba(var(--color-foreground), 0.12));
    {%- else -%}
      border: 1px solid var(--cpc-card-content-border-color, rgba(var(--color-foreground), 0.12));
    {%- endif -%}
    {%- if card_content_border_radius > 0 -%}
      border-radius: var(--cpc-card-content-border-radius);
    {%- else -%}
      border-radius: 1.4rem;
    {%- endif -%}
    box-shadow: 0 2px 12px rgba(var(--color-foreground), 0.06);
    position: relative;
    z-index: 10;
    text-decoration: none;
    cursor: pointer;
    pointer-events: auto;
    transition: transform 0.3s ease, opacity 0.3s ease;
  }

  .cpc-section--{{ section_id }} .cpc-info-card:hover {
    opacity: 0.95;
  }

  .cpc-section--{{ section_id }} .cpc-info-card:active {
    opacity: 0.9;
  }

  .cpc-section--{{ section_id }} .cpc-info-thumb {
    flex-shrink: 0;
    width: 5.6rem;
    height: 5.6rem;
    border-radius: 0.8rem;
    overflow: hidden;
    background: rgba(var(--color-foreground), 0.03);
  }

  @media screen and (max-width: 749px) {
    .cpc-section--{{ section_id }} .cpc-info-thumb {
      width: 4.4rem;
      height: 4.4rem;
    }
  }

  .cpc-section--{{ section_id }} .cpc-info-thumb-image {
    width: 100%;
    height: 100%;
    object-fit: cover;
    display: block;
  }

  .cpc-section--{{ section_id }} .cpc-info-thumb-placeholder {
    width: 100%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .cpc-section--{{ section_id }} .cpc-info-thumb-placeholder svg {
    width: 100%;
    height: 100%;
    opacity: 0.3;
  }

  .cpc-section--{{ section_id }} .cpc-info-text {
    flex: 1;
    min-width: 0;
    display: flex;
    flex-direction: column;
    gap: 0.4rem;
  }

  .cpc-section--{{ section_id }} .cpc-info-title {
    font-size: 1.5rem;
    font-weight: 600;
    margin: 0;
    line-height: 1.3;
    color: var(--cpc-card-content-text, rgba(var(--color-foreground), 1));
    display: -webkit-box;
    -webkit-line-clamp: 1;
    -webkit-box-orient: vertical;
    overflow: hidden;
  }

  @media screen and (max-width: 749px) {
    .cpc-section--{{ section_id }} .cpc-info-title {
      font-size: 1.4rem;
    }
  }

  .cpc-section--{{ section_id }} .cpc-info-price {
    display: flex;
    align-items: center;
    gap: 0.8rem;
    font-size: 1.4rem;
    font-weight: 600;
    color: var(--cpc-card-content-text, rgba(var(--color-foreground), 1));
  }

  @media screen and (max-width: 749px) {
    .cpc-section--{{ section_id }} .cpc-info-price {
      font-size: 1.3rem;
    }
  }

  .cpc-section--{{ section_id }} .cpc-price-compare {
    text-decoration: line-through;
    opacity: 0.6;
    font-size: 1.2rem;
    font-weight: 400;
    color: var(--cpc-card-content-text, rgba(var(--color-foreground), 0.6));
  }

  @media screen and (max-width: 749px) {
    .cpc-section--{{ section_id }} .cpc-price-compare {
      font-size: 1.1rem;
    }
  }

  .cpc-section--{{ section_id }} .cpc-price-current {
    color: var(--cpc-card-content-text, rgba(var(--color-foreground), 1));
  }

  .cpc-section--{{ section_id }} .cpc-info-caret {
    flex-shrink: 0;
    width: 1.6rem;
    height: 1.6rem;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--cpc-card-content-text, rgba(var(--color-foreground), 0.5));
  }

  .cpc-section--{{ section_id }} .cpc-info-caret svg {
    width: 100%;
    height: 100%;
  }

  .cpc-section--{{ section_id }} .cpc-arrow {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    width: 4.4rem;
    height: 4.4rem;
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.95);
    border: 1px solid rgba(var(--color-foreground), 0.1);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    z-index: 3;
    transition: transform 0.2s ease, background 0.2s ease, opacity 0.2s ease;
    color: rgba(var(--color-foreground), 1);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
  }

  .cpc-section--{{ section_id }} .cpc-arrow:hover:not(:disabled) {
    transform: translateY(-50%) scale(1.1);
    background: rgba(255, 255, 255, 1);
  }

  .cpc-section--{{ section_id }} .cpc-arrow:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .cpc-section--{{ section_id }} .cpc-arrow--prev {
    left: 0;
  }

  .cpc-section--{{ section_id }} .cpc-arrow--next {
    right: 0;
  }

  .cpc-section--{{ section_id }} .cpc-dots {
    display: flex;
    justify-content: center;
    gap: 0.8rem;
    margin-top: 2rem;
  }

  .cpc-section--{{ section_id }} .cpc-dot {
    width: 0.8rem;
    height: 0.8rem;
    border-radius: 50%;
    border: none;
    background: rgba(var(--color-foreground), 0.3);
    cursor: pointer;
    transition: background 0.3s ease, transform 0.3s ease;
    padding: 0;
  }

  .cpc-section--{{ section_id }} .cpc-dot:hover {
    transform: scale(1.2);
  }

  .cpc-section--{{ section_id }} .cpc-dot--active {
    background: rgba(var(--color-foreground), 1);
    transform: scale(1.3);
  }

  .cpc-section--{{ section_id }} .cpc-empty {
    text-align: center;
    padding: 4rem 2rem;
    color: rgba(var(--color-foreground), 0.6);
  }

  .cpc-section--{{ section_id }} .cpc-card-image {
    -webkit-user-drag: none;
    user-drag: none;
  }

  .cpc-section--{{ section_id }} .cpc-card,
  .cpc-section--{{ section_id }} .cpc-card * {
    -webkit-user-drag: none;
    user-drag: none;
  }

  .cpc-section--{{ section_id }} .cpc-track {
    cursor: grab;
    touch-action: pan-y;
  }

  /* Ensure info card links are always clickable */
  .cpc-section--{{ section_id }} .cpc-info-card,
  .cpc-section--{{ section_id }} .cpc-info-card * {
    pointer-events: auto;
  }

  .cpc-section--{{ section_id }} .cpc-track:active {
    cursor: grabbing;
  }
</style>

<script>
  // Immediately stop any GIFs on page load (except in active slide)
  (function() {
    const sectionId = '{{ section_id }}';
    const section = document.querySelector(`#CenterProductCarousel-${sectionId}`);
    if (section) {
      const allSlides = section.querySelectorAll('.cpc-slide');
      allSlides.forEach((slide) => {
        // Only stop GIFs in non-active slides
        if (!slide.classList.contains('is-active')) {
          const gifImages = slide.querySelectorAll('.cpc-gif-image[data-gif-url]');
          gifImages.forEach((img) => {
            const gifUrl = img.dataset.gifUrl;
            const placeholderUrl = img.dataset.placeholderUrl;
            if (gifUrl && placeholderUrl) {
              const baseGifUrl = gifUrl.split('?')[0].split('#')[0];
              // If it's showing the GIF, swap to placeholder
              if (img.src.includes(baseGifUrl)) {
                img.src = placeholderUrl;
              }
            }
          });
        }
      });
    }
  })();
</script>

<script>
  (function () {
    'use strict';

    const sectionId = '{{ section_id }}';
    const section = document.querySelector(`#CenterProductCarousel-${sectionId}`);
    if (!section) return;

    const viewport = section.querySelector('[data-viewport]');
    const track = section.querySelector('[data-track]');
    const prevBtn = section.querySelector('.cpc-arrow--prev');
    const nextBtn = section.querySelector('.cpc-arrow--next');
    const dots = Array.from(section.querySelectorAll('[data-dot-index]'));

    const autoplayEnabled = section.dataset.autoplay === 'true';
    const autoplayDelay = (parseInt(section.dataset.autoplayDelay, 10) || 5) * 1000;

    if (!track || !viewport) return;

    let originalSlides = [];
    let slides = [];
    let originalCount = 0;
    let clonesCount = 0;
    let currentIndex = 0;
    let currentRealIndex = 0;
    let autoplayTimer = null;
    let isPaused = false;
    let scrollRaf = null;
    let isScrolling = false;
    let isCorrecting = false;
    let isProgrammaticScroll = false;
    let isDragging = false;

    function getSlidesPerView() {
      if (window.matchMedia('(min-width: 990px)').matches) return 3;
      if (window.matchMedia('(min-width: 750px)').matches) return 2;
      return 1;
    }

    /**
     * Get closest slide to center using scroll position and offsets (not getBoundingClientRect)
     * This is reliable even with CSS transforms and cloned slides
     */
    function getClosestIndexToCenter() {
      if (slides.length === 0) return 0;

      const scrollLeft = track.scrollLeft;
      const trackCenter = track.offsetWidth / 2;
      const viewportCenter = scrollLeft + trackCenter;

      let closestIndex = 0;
      let closestDistance = Infinity;

      slides.forEach((slide, index) => {
        // Use offsetLeft + offsetWidth/2 to get slide center position
        // This is unaffected by CSS transforms
        const slideLeft = slide.offsetLeft;
        const slideWidth = slide.offsetWidth;
        const slideCenter = slideLeft + slideWidth / 2;
        
        // Calculate distance from viewport center to slide center
        const distance = Math.abs(viewportCenter - slideCenter);
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestIndex = index;
        }
      });

      return closestIndex;
    }

    function getOriginalIndexByReal(realIndex) {
      const s = slides[realIndex];
      const v = s ? parseInt(s.dataset.originalIndex || '0', 10) : 0;
      return Number.isNaN(v) ? 0 : v;
    }

    function getRealIndex(originalIndex) {
      return clonesCount + originalIndex;
    }

    /**
     * Set active slide - ensures exactly ONE slide has .is-active at all times
     */
    function setActiveByRealIndex(realIndex) {
      // Clamp to valid range
      realIndex = Math.max(0, Math.min(slides.length - 1, realIndex));
      
      // Remove is-active from ALL slides first
      slides.forEach((slide) => {
        slide.classList.remove('is-active');
      });
      
      // Then add to the correct one
      if (slides[realIndex]) {
        slides[realIndex].classList.add('is-active');
        
        // Preload GIF for active slide immediately (in background, doesn't display yet)
        if (!isDragging && !isInertia) {
          const gifImages = slides[realIndex].querySelectorAll('.cpc-gif-image[data-gif-url]');
          gifImages.forEach((img) => {
            const gifUrl = img.dataset.gifUrl;
            if (gifUrl) {
              // Preload in background for faster display when scroll settles
              preloadGif(gifUrl);
            }
          });
        }
      }
    }

    /**
     * Preload GIF in background (doesn't display it, just loads into browser cache)
     */
    function preloadGif(gifUrl) {
      if (!gifUrl) return;
      const link = document.createElement('link');
      link.rel = 'preload';
      link.as = 'image';
      link.href = gifUrl;
      document.head.appendChild(link);
      // Remove after a short delay to clean up
      setTimeout(() => {
        if (link.parentNode) {
          link.parentNode.removeChild(link);
        }
      }, 1000);
    }

    /**
     * STRICT GIF CONTROL: Only ONE GIF plays at a time, only on centered slide, only after scroll settles
     * @param {number} realIndex - The real index of the slide that should have its GIF playing
     */
    function updateCenterGif(realIndex) {
      // Lock GIF during drag or inertia
      if (isDragging || isInertia) return;
      
      // Stop ALL GIFs in this section first (section-scoped, not global)
      const allGifImages = section.querySelectorAll('.cpc-gif-image[data-gif-url]');
      allGifImages.forEach((img) => {
        const gifUrl = img.dataset.gifUrl;
        const placeholderUrl = img.dataset.placeholderUrl;
        
        if (gifUrl && placeholderUrl) {
          const baseGifUrl = gifUrl.split('?')[0].split('#')[0];
          // If showing GIF, swap to placeholder
          if (img.src.includes(baseGifUrl)) {
            img.src = placeholderUrl;
            img.removeAttribute('srcset');
          }
        }
      });
      
      // Now start GIF ONLY for the centered slide
      if (realIndex >= 0 && realIndex < slides.length) {
        const centerSlide = slides[realIndex];
        if (centerSlide) {
          const gifImages = centerSlide.querySelectorAll('.cpc-gif-image[data-gif-url]');
          gifImages.forEach((img) => {
            const gifUrl = img.dataset.gifUrl;
            const placeholderUrl = img.dataset.placeholderUrl;
            
            if (gifUrl && placeholderUrl) {
              // Set src directly - no cache-busting, instant from cache
              img.src = gifUrl;
            }
          });
        }
      }
    }

    function updateDots() {
      // Dots removed - no-op
    }

    // Simple debounce settle engine
    let settleTimer = null;
    const SETTLE_DELAY = 90; // ms

    /**
     * Schedule settle - finalizes loop correction + GIF after scroll stops
     */
    function scheduleSettle() {
      clearTimeout(settleTimer);
      settleTimer = setTimeout(() => {
        if (isDragging || isInertia || isCorrecting) return;
        // finalize: loop correction + gif
        settleScroll();
      }, SETTLE_DELAY);
    }

    // rAF active preview updater - makes center card pop instantly during scroll
    let activeRaf = null;
    function scheduleActivePreview() {
      if (activeRaf) return;
      activeRaf = requestAnimationFrame(() => {
        activeRaf = null;
        if (!slides.length) return;

        // compute closest index based on current scrollLeft
        const idx = getClosestIndexToCenter();

        if (idx !== currentRealIndex) {
          currentRealIndex = idx;
          currentIndex = getOriginalIndexByReal(idx);
          setActiveByRealIndex(idx); // THIS makes the "push up" immediate
          updateDots();
        }
      });
    }

    /**
     * Process scroll settle - handle correction and GIF only
     * Active state is already updated by scheduleActivePreview() during scroll
     */
    function settleScroll() {
      // Compute centered slide using scroll position (reliable with transforms)
      const centeredIndex = getClosestIndexToCenter();
      
      // Handle infinite loop correction if needed
      let needsCorrection = false;
      
      if (centeredIndex < clonesCount) {
        // In prepended copies - jump to corresponding position in middle copy
        needsCorrection = true;
      } else if (centeredIndex >= clonesCount + originalCount) {
        // In appended copies - jump to corresponding position in middle copy
        needsCorrection = true;
      }
      
      // If correction needed, handle it
      if (needsCorrection) {
        correctPosition();
      } else {
        // We're in the middle copy - just update GIF (active already set by preview)
        updateCenterGif(centeredIndex);
      }
    }

    /**
     * Handle scroll events - instantly update active state, schedule settle for correction + GIF
     */
    function onScroll() {
      if (isDragging || isInertia) {
        scheduleActivePreview();
        // no settle while dragging/inertia
        return;
      }
      scheduleActivePreview();
      scheduleSettle();
    }

    /**
     * Correct position when in cloned regions - instant jump without fighting animation
     */
    function correctPosition() {
      if (isCorrecting || slides.length === 0) return;
      
      // Use scroll position-based detection (reliable with transforms)
      const closestReal = getClosestIndexToCenter();
      let corrected = closestReal;
      let needsJump = false;
      
      // With 3 copies per side, we have: [PRE x3] + [MIDDLE] + [POST x3]
      // Middle starts at clonesCount, ends at clonesCount + originalCount
      if (closestReal < clonesCount) {
        // In prepended copies - jump to corresponding position in middle copy
        const offsetInPre = closestReal % originalCount;
        corrected = clonesCount + offsetInPre;
        needsJump = true;
      } else if (closestReal >= clonesCount + originalCount) {
        // In appended copies - jump to corresponding position in middle copy
        const offsetInPost = (closestReal - clonesCount - originalCount) % originalCount;
        corrected = clonesCount + offsetInPost;
        needsJump = true;
      }
      
      // Only jump if we're actually in a clone region
      if (needsJump) {
        isCorrecting = true;
        const target = slides[corrected];
        if (target) {
          // Ensure scroll behavior is auto for instant jump
          const originalScrollBehavior = track.style.scrollBehavior;
          track.style.scrollBehavior = 'auto';
          
          // Instant jump
          requestAnimationFrame(() => {
            track.scrollTo({
              left: target.offsetLeft - (track.offsetWidth / 2) + (target.offsetWidth / 2),
              behavior: 'auto'
            });
            
            // Wait 1 rAF for jump to complete
            requestAnimationFrame(() => {
              // Update indices and active state
              currentRealIndex = corrected;
              currentIndex = getOriginalIndexByReal(corrected);
              setActiveByRealIndex(corrected);
              updateDots();
              
              // Restore scroll behavior
              track.style.scrollBehavior = originalScrollBehavior;
              
              // Update GIF after correction
              updateCenterGif(corrected);
              
              // Allow correction to complete
              isCorrecting = false;
            });
          });
        } else {
          isCorrecting = false;
        }
      } else {
        // We're in the middle copy - just update GIF (active already set by preview)
        updateCenterGif(corrected);
      }
    }

    /**
     * Scroll to centered position - uses new active preview + settle system
     */
    function scrollToCentered(target, smooth = true) {
      if (!target) return;
      
      // Calculate target position
      const targetLeft = target.offsetLeft - (track.offsetWidth / 2) + (target.offsetWidth / 2);
      
      // For smooth scrolling, use native smooth behavior
      // For instant, use auto
      if (smooth) {
        track.scrollTo({
          left: targetLeft,
          behavior: 'smooth'
        });
      } else {
        track.scrollLeft = targetLeft;
      }

      // Immediately update active preview and schedule settle
      scheduleActivePreview();
      scheduleSettle();
    }

    function scrollToRealIndex(realIndex, smooth = true) {
      if (slides.length === 0) return;
      
      // Clamp to valid range
      realIndex = Math.max(0, Math.min(slides.length - 1, realIndex));
      const target = slides[realIndex];
      
      if (!target) return;

      isProgrammaticScroll = true;
      
      // Use unified scroll to centered function
      scrollToCentered(target, smooth);

      // Clear programmatic flag after settle completes
      setTimeout(() => {
        isProgrammaticScroll = false;
      }, smooth ? 800 : 200);

      if (autoplayEnabled && !isPaused) resetAutoplay();
    }

    function scrollToOriginalIndex(originalIndex, smooth = true) {
      if (originalCount === 0) return;
      
      originalIndex = ((originalIndex % originalCount) + originalCount) % originalCount;
      const realIndex = getRealIndex(originalIndex);
      scrollToRealIndex(realIndex, smooth);
    }

    function scrollToPrev() {
      if (slides.length <= 1) return;
      // Allow going into prepended copy naturally - correction only happens on user scroll
      const newRealIndex = Math.max(0, currentRealIndex - 1);
      scrollToRealIndex(newRealIndex, true);
    }

    function scrollToNext() {
      if (slides.length <= 1) return;
      // Allow going into appended copy naturally - correction only happens on user scroll
      const newRealIndex = Math.min(slides.length - 1, currentRealIndex + 1);
      scrollToRealIndex(newRealIndex, true);
    }

    function startAutoplay() {
      if (!autoplayEnabled || isPaused || originalCount <= 1) return;
      autoplayTimer = window.setInterval(() => {
        scrollToNext();
      }, autoplayDelay);
    }

    function pauseAutoplay() {
      isPaused = true;
      if (autoplayTimer) {
        clearInterval(autoplayTimer);
        autoplayTimer = null;
      }
    }

    function resumeAutoplay() {
      isPaused = false;
      startAutoplay();
    }

    function resetAutoplay() {
      pauseAutoplay();
      resumeAutoplay();
    }

    // ----- Drag / Swipe (reliable + click-safe) -----
    const DRAG_START_PX = 8;

    let isPointerDown = false;
    let moved = false;
    let startX = 0;
    let startScrollLeft = 0;

    // rAF-driven scroll scheduler
    let dragRaf = null;
    let pendingScrollLeft = 0;
    let lastMoveX = 0;
    let lastMoveT = 0;
    let velocity = 0; // px/ms
    let inertiaRaf = null;
    let isInertia = false;

    // When we drag, suppress link clicks briefly after release
    let suppressClickUntil = 0;

    // Double-tap detection
    let lastTapTime = 0;
    let lastTapTarget = null;
    const DOUBLE_TAP_DELAY = 300; // ms between taps
    const DOUBLE_TAP_DISTANCE = 50; // max pixel distance between taps

    /**
     * Schedule scrollLeft update via rAF for smooth batched updates
     */
    function scheduleScrollLeft(value) {
      pendingScrollLeft = value;
      if (dragRaf) return;
      dragRaf = requestAnimationFrame(() => {
        track.scrollLeft = pendingScrollLeft;
        dragRaf = null;
      });
    }

    /**
     * Stop ALL GIFs in the section (including active slide) during drag
     */
    function stopAllGifsInSection() {
      const imgs = section.querySelectorAll('.cpc-gif-image[data-gif-url]');
      imgs.forEach(img => {
        const gifUrl = img.dataset.gifUrl;
        const placeholderUrl = img.dataset.placeholderUrl;
        if (!gifUrl || !placeholderUrl) return;
        const base = gifUrl.split('?')[0].split('#')[0];
        if (img.src && img.src.includes(base)) {
          img.src = placeholderUrl;
          img.removeAttribute('srcset');
        }
      });
    }

    /**
     * Start inertia scroll after drag release
     */
    function startInertiaScroll() {
      if (inertiaRaf) cancelAnimationFrame(inertiaRaf);
      isInertia = true;

      const DECAY = 0.95; // per frame-ish
      let lastT = performance.now();

      function step() {
        const now = performance.now();
        const dt = Math.min(32, now - lastT);
        lastT = now;

        // advance scroll
        const next = track.scrollLeft + velocity * dt;
        scheduleScrollLeft(next);

        // Update center highlight during inertia
        scheduleActivePreview();

        // decay velocity
        velocity *= Math.pow(DECAY, dt / 16);

        if (Math.abs(velocity) < 0.03) {
          isInertia = false;
          inertiaRaf = null;

          // snap to nearest slide (smooth)
          const closest = getClosestIndexToCenter();
          const target = slides[closest];
          if (target) scrollToCentered(target, true);

          return;
        }

        inertiaRaf = requestAnimationFrame(step);
      }

      inertiaRaf = requestAnimationFrame(step);
    }

    function handleWheel(e) {
      if (originalCount <= 1) return;

      const absX = Math.abs(e.deltaX);
      const absY = Math.abs(e.deltaY);

      const isVerticalIntent = absY > absX && !e.shiftKey;

      // Vertical scroll → PAGE scroll only
      if (isVerticalIntent) {
        e.preventDefault();
        window.scrollBy({
          top: e.deltaY,
          behavior: 'auto'
        });
        return;
      }

      // Horizontal intent → carousel scroll with momentum
      e.preventDefault();
      const delta = absX > 0 ? e.deltaX : e.deltaY;
      
      // Apply momentum multiplier for smoother trackpad scrolling
      const momentumMultiplier = Math.abs(delta) > 10 ? 1.2 : 1;
      track.scrollLeft += delta * momentumMultiplier;
      
      // Update active preview and schedule settle
      scheduleActivePreview();
      scheduleSettle();
    }

    function handlePointerDown(e) {
      if (originalCount <= 1) return;
      if (e.pointerType === 'mouse' && e.button !== 0) return;

      // Don't start drag if clicking on info card link
      const link = e.target.closest('a.cpc-info-card');
      if (link) return; // Let the link handle the click

      // Stop all GIFs before dragging starts
      stopAllGifsInSection();

      // Cancel any ongoing inertia
      if (inertiaRaf) {
        cancelAnimationFrame(inertiaRaf);
        inertiaRaf = null;
        isInertia = false;
      }

      isPointerDown = true;
      moved = false;
      isDragging = false;

      startX = e.clientX;
      startScrollLeft = track.scrollLeft;

      // Reset velocity tracking
      lastMoveX = e.clientX;
      lastMoveT = performance.now();
      velocity = 0;

      track.classList.add('is-dragging');
      track.style.cursor = 'grabbing';
      track.style.userSelect = 'none';

      // Capture pointer so we still get pointerup even if pointer leaves the track
      try {
        track.setPointerCapture(e.pointerId);
      } catch (err) {}
    }

    function handlePointerMove(e) {
      if (!isPointerDown) return;

      const dx = e.clientX - startX;

      // Only treat it as a drag after a small threshold (keeps taps as taps)
      if (!moved && Math.abs(dx) > DRAG_START_PX) {
        moved = true;
        isDragging = true;
      }

      if (moved) {
        isDragging = true;
        // prevent the browser from interpreting as a "scroll/tap"
        e.preventDefault();

        // Reset double-tap tracking when dragging
        lastTapTime = 0;
        lastTapTarget = null;

        // Compute velocity (px/ms)
        const now = performance.now();
        const dt = Math.max(8, now - lastMoveT);
        const dxStep = e.clientX - lastMoveX;
        // scrollLeft moves opposite to pointer movement:
        const v = (-dxStep) / dt;
        // smooth it:
        velocity = velocity * 0.8 + v * 0.2;
        lastMoveX = e.clientX;
        lastMoveT = now;

        // Drag-to-scroll using rAF scheduler
        const next = startScrollLeft - dx;
        scheduleScrollLeft(next);
        
        // Update center highlight while dragging
        scheduleActivePreview();
        
        // Update last scroll position for settle engine
        lastScrollLeft = next;
      }
    }

    function handlePointerUp(e) {
      if (!isPointerDown) return;

      isPointerDown = false;

      track.classList.remove('is-dragging');
      track.style.cursor = 'grab';
      track.style.userSelect = '';

      try {
        track.releasePointerCapture(e.pointerId);
      } catch (err) {}

      isDragging = false;

      if (moved) {
        // We dragged: suppress accidental clicks for a short window
        suppressClickUntil = Date.now() + 350;

        // Start inertia if velocity is meaningful, otherwise snap immediately
        if (Math.abs(velocity) > 0.15) {
          startInertiaScroll();
        } else {
          const closest = getClosestIndexToCenter();
          const target = slides[closest];
          if (target) scrollToCentered(target, true);
        }
      }

      // reset moved shortly after (keep window for click suppression)
      setTimeout(() => {
        moved = false;
      }, 0);
    }

    function buildInfiniteLoop() {
      // For 1 or fewer slides, no loop needed
      if (originalCount <= 1) {
        slides = Array.from(originalSlides);
        clonesCount = 0;
        currentRealIndex = 0;
        currentIndex = 0;
        setActiveByRealIndex(0);
        updateDots();
        return;
      }

      // Remove existing clones
      const existingClones = track.querySelectorAll('.cpc-slide[data-clone="1"]');
      existingClones.forEach(clone => clone.remove());

      // Create 3 full copies on each side for seamless infinite loop
      const copiesPerSide = 3;
      clonesCount = originalCount * copiesPerSide;

      // Prepend 3 FULL copies in original order
      for (let copy = 0; copy < copiesPerSide; copy++) {
        for (let i = 0; i < originalCount; i++) {
          const clone = originalSlides[i].cloneNode(true);
          clone.dataset.clone = '1';
          clone.dataset.originalIndex = i;
          track.insertBefore(clone, originalSlides[0]);
        }
      }

      // Append 3 FULL copies in original order
      for (let copy = 0; copy < copiesPerSide; copy++) {
        for (let i = 0; i < originalCount; i++) {
          const clone = originalSlides[i].cloneNode(true);
          clone.dataset.clone = '1';
          clone.dataset.originalIndex = i;
          track.appendChild(clone);
        }
      }

      // Rebuild slides array
      slides = Array.from(track.querySelectorAll('.cpc-slide'));
      
      // Start in the middle copy (first slide of middle copy)
      const middleStartIndex = clonesCount + currentIndex;
      const middleStartSlide = slides[middleStartIndex];
      if (middleStartSlide) {
        track.scrollTo({
          left: middleStartSlide.offsetLeft - (track.offsetWidth / 2) + (middleStartSlide.offsetWidth / 2),
          behavior: 'auto'
        });
      }
      
      currentRealIndex = middleStartIndex;
      setActiveByRealIndex(middleStartIndex);
      updateDots();
      
      // Trigger active preview and settle after initialization to update GIF
      requestAnimationFrame(() => {
        if (track) {
          // Manually trigger active preview and settle for initial load
          scheduleActivePreview();
          scheduleSettle();
        }
      });
    }

    function init() {
      // Get original slides
      originalSlides = Array.from(track.querySelectorAll('.cpc-slide')).filter(slide => !slide.dataset.clone);
      originalCount = originalSlides.length;
      
      if (originalCount === 0) return;

      // Mark original slides with data-original-index
      originalSlides.forEach((slide, index) => {
        slide.dataset.originalIndex = index;
      });

      // Build infinite loop
      buildInfiniteLoop();

      track.addEventListener('scroll', () => {
        onScroll();
      }, { passive: true });

      track.addEventListener('pointerdown', handlePointerDown);
      track.addEventListener('pointermove', handlePointerMove, { passive: false });
      track.addEventListener('pointerup', handlePointerUp);
      track.addEventListener('pointercancel', handlePointerUp);
      track.addEventListener('wheel', handleWheel, { passive: false });

      // Register click handler for product links
      section.addEventListener('click', (e) => {
        const link = e.target.closest('a.cpc-info-card');
        if (!link) return;

        // Only block clicks if a REAL drag happened (moved flag is set and within suppression window)
        if (moved && Date.now() < suppressClickUntil) {
          e.preventDefault();
          e.stopPropagation();
          return;
        }

        // Double-tap detection - only if no drag occurred
        if (!moved) {
          const currentTime = Date.now();
          const timeSinceLastTap = currentTime - lastTapTime;
          const isDoubleTap = timeSinceLastTap < DOUBLE_TAP_DELAY && 
                             lastTapTarget === link;

          if (isDoubleTap) {
            // Double tap detected - navigate immediately
            e.preventDefault();
            e.stopPropagation();
            const href = link.getAttribute('href');
            if (href) {
              window.location.href = href;
            }
            // Reset tap tracking
            lastTapTime = 0;
            lastTapTarget = null;
          } else {
            // Single tap - store for potential double tap, but allow default navigation
            lastTapTime = currentTime;
            lastTapTarget = link;
            
            // Clear after delay
            setTimeout(() => {
              if (Date.now() - lastTapTime >= DOUBLE_TAP_DELAY) {
                lastTapTime = 0;
                lastTapTarget = null;
              }
            }, DOUBLE_TAP_DELAY);
          }
        }
        // If moved is false and not double-tap, default link behavior will happen naturally
      }, false); // Use bubbling phase so link's default behavior works

      if (autoplayEnabled) {
        startAutoplay();
        section.addEventListener('mouseenter', pauseAutoplay);
        section.addEventListener('mouseleave', resumeAutoplay);
        section.addEventListener('focusin', pauseAutoplay);
        section.addEventListener('focusout', resumeAutoplay);
      }

      // Handle window resize
      let resizeTimeout;
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
          buildInfiniteLoop();
        }, 250);
      });
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', init);
    } else {
      init();
    }

    document.addEventListener('shopify:section:load', function (e) {
      const root = e.detail || e.target;
      const loaded = root.querySelector
        ? root.querySelector(`#CenterProductCarousel-${sectionId}`)
        : (root.id === `CenterProductCarousel-${sectionId}` ? root : null);

      if (loaded) setTimeout(init, 60);
    });

  })();
</script>

{% schema %}
{
  "name": "Center Product Carousel",
  "tag": "section",
  "class": "section",
  "settings": [
    {
      "type": "text",
      "id": "heading",
      "label": "Heading",
      "default": "Featured Products"
    },
    {
      "type": "text",
      "id": "subheading",
      "label": "Subheading"
    },
    {
      "type": "select",
      "id": "alignment",
      "label": "Heading alignment",
      "options": [
        {
          "value": "left",
          "label": "Left"
        },
        {
          "value": "center",
          "label": "Center"
        },
        {
          "value": "right",
          "label": "Right"
        }
      ],
      "default": "center"
    },
    {
      "type": "range",
      "id": "heading_size",
      "label": "Heading size",
      "min": 16,
      "max": 60,
      "step": 2,
      "default": 24,
      "unit": "px"
    },
    {
      "type": "color",
      "id": "heading_color",
      "label": "Heading color",
      "info": "Leave empty to use theme default text color"
    },
    {
      "type": "range",
      "id": "gap",
      "label": "Gap between cards",
      "min": 0,
      "max": 50,
      "step": 2,
      "default": 20,
      "unit": "px"
    },
    {
      "type": "range",
      "id": "card_radius",
      "label": "Card border radius (top)",
      "min": 0,
      "max": 50,
      "step": 2,
      "default": 18,
      "unit": "px"
    },
    {
      "type": "range",
      "id": "card_bottom_radius",
      "label": "Card border radius (bottom)",
      "min": 0,
      "max": 50,
      "step": 2,
      "default": 18,
      "unit": "px"
    },
    {
      "type": "range",
      "id": "card_width",
      "label": "Card max width",
      "min": 200,
      "max": 800,
      "step": 20,
      "default": 400,
      "unit": "px",
      "info": "Maximum width for each card. Leave empty for full width."
    },
    {
      "type": "checkbox",
      "id": "show_vendor",
      "label": "Show vendor",
      "default": false
    },
    {
      "type": "checkbox",
      "id": "show_color_swatches",
      "label": "Show color swatches",
      "default": true
    },
    {
      "type": "color",
      "id": "card_content_bg_color",
      "label": "Card content background color",
      "info": "Background color for the product information area"
    },
    {
      "type": "color",
      "id": "card_content_text_color",
      "label": "Card content text color",
      "info": "Text color for product title, price, and vendor"
    },
    {
      "type": "header",
      "content": "Card Content Border"
    },
    {
      "type": "color",
      "id": "card_content_border_color",
      "label": "Border color"
    },
    {
      "type": "range",
      "id": "card_content_border_width",
      "label": "Border width",
      "min": 0,
      "max": 10,
      "step": 1,
      "default": 0,
      "unit": "px"
    },
    {
      "type": "range",
      "id": "card_content_border_radius",
      "label": "Border radius",
      "min": 0,
      "max": 50,
      "step": 2,
      "default": 0,
      "unit": "px"
    },
    {
      "type": "range",
      "id": "card_content_padding",
      "label": "Padding",
      "min": 0,
      "max": 60,
      "step": 2,
      "default": 24,
      "unit": "px"
    },
    {
      "type": "range",
      "id": "card_content_margin",
      "label": "Margin",
      "min": 0,
      "max": 60,
      "step": 2,
      "default": 0,
      "unit": "px"
    },
    {
      "type": "checkbox",
      "id": "show_arrows",
      "label": "Show navigation arrows",
      "default": true
    },
    {
      "type": "checkbox",
      "id": "show_dots",
      "label": "Show dots indicator",
      "default": true
    },
    {
      "type": "checkbox",
      "id": "autoplay",
      "label": "Enable autoplay",
      "default": false
    },
    {
      "type": "range",
      "id": "autoplay_seconds",
      "label": "Autoplay delay",
      "min": 2,
      "max": 10,
      "step": 1,
      "default": 5,
      "unit": "s",
      "info": "Only applies if autoplay is enabled"
    }
  ],
  "blocks": [
    {
      "type": "product",
      "name": "Product",
      "settings": [
        {
          "type": "product",
          "id": "product",
          "label": "Product"
        },
        {
          "type": "text",
          "id": "badge_text",
          "label": "Badge text",
          "info": "Optional badge text to display on the media"
        },
        {
          "type": "select",
          "id": "media_source",
          "label": "Media source",
          "options": [
            {
              "value": "product_featured",
              "label": "Product featured image"
            },
            {
              "value": "custom_image_or_gif",
              "label": "Custom image/GIF"
            },
            {
              "value": "external_gif_url",
              "label": "External GIF URL"
            }
          ],
          "default": "product_featured"
        },
        {
          "type": "image_picker",
          "id": "custom_media",
          "label": "Custom image/GIF",
          "info": "Only used if media source is 'Custom image/GIF'"
        },
        {
          "type": "text",
          "id": "external_gif_url",
          "label": "External GIF URL",
          "info": "Only used if media source is 'External GIF URL'"
        },
        {
          "type": "image_picker",
          "id": "placeholder_image",
          "label": "Placeholder image",
          "info": "Static image to show when GIF is not in center. If not set, uses product featured image."
        },
        {
          "type": "text",
          "id": "alt_text",
          "label": "Alt text",
          "info": "Override default alt text for the image"
        },
        {
          "type": "select",
          "id": "focal_position",
          "label": "Focal point",
          "options": [
            {
              "value": "center",
              "label": "Center"
            },
            {
              "value": "top",
              "label": "Top"
            },
            {
              "value": "bottom",
              "label": "Bottom"
            }
          ],
          "default": "center"
        }
      ]
    }
  ],
  "presets": [
    {
      "name": "Center Product Carousel",
      "blocks": [
        {
          "type": "product"
        },
        {
          "type": "product"
        },
        {
          "type": "product"
        }
      ]
    }
  ]
}
{% endschema %}

