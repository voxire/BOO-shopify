{%- liquid
  assign id = section.id
  assign slides = section.blocks
-%}

<style>
.carousel-arc-{{ id }} {
  background: #0a0a0a;
  padding: 80px 0;
  overflow: hidden;
}

.carousel-arc-scene-{{ id }} {
  perspective: 2500px;
  perspective-origin: center center;
  display: flex;
  justify-content: center;
  transform-style: preserve-3d;
}

.carousel-arc-track-{{ id }} {
  position: relative;
  width: 600px;
  height: 600px;
  transform-style: preserve-3d;
  cursor: grab;
  user-select: none;
}

.carousel-arc-track-{{ id }}:active {
  cursor: grabbing;
}

.carousel-arc-item-{{ id }} {
  position: absolute;
  inset: 0;
  border-radius: 16px;
  overflow: hidden;
  transform-origin: center center;
  transition: opacity 0.3s ease;
  backface-visibility: hidden;
  will-change: transform, opacity;
  cursor: pointer;
}

.carousel-arc-item-{{ id }} img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Mobile */
@media (max-width: 768px) {
  .carousel-arc-track-{{ id }} {
    width: 400px;
    height: 400px;
  }
}
</style>

<section class="carousel-arc-{{ id }}">
  <div class="carousel-arc-scene-{{ id }}">
    <div class="carousel-arc-track-{{ id }}" data-track>
      {%- for block in slides -%}
        <div
          class="carousel-arc-item-{{ id }}"
          data-index="{{ forloop.index0 }}">
          {%- if block.settings.image != blank -%}
            <img
              src="{{ block.settings.image | image_url: width: 1200 }}"
              alt="{{ block.settings.image.alt | escape }}"
              loading="lazy">
          {%- else -%}
            <div style="width: 100%; height: 100%; background: #f5f5f5; display: flex; align-items: center; justify-content: center; color: #999; border-radius: 16px;">
              {{ 'image' | placeholder_svg_tag: 'placeholder' }}
            </div>
          {%- endif -%}
        </div>
      {%- endfor -%}
    </div>
  </div>
</section>

<script>
(() => {
  const track = document.querySelector('[data-track]');
  if (!track) return;

  const items = [...track.children];
  const total = items.length;

  if (total === 0) return;

  // Floating active index for continuous interpolation
  let active = 0;
  let target = 0;
  let hoveredIndex = -1; // Track which card is being hovered

  // Animation loop
  let animationId = null;
  let isAnimating = true;

  function animate() {
    // Normalize target periodically to prevent extreme values
    normalizeTarget();
    
    // Interpolate active towards target
    active += (target - active) * 0.08;
    
    render();
    
    if (isAnimating) {
      animationId = requestAnimationFrame(animate);
    }
  }

  function render() {
    // Hexagon layout: 6 images arranged in a hexagon, touching each other
    // Center image (active) + 5 surrounding images
    const cardWidth = 420; // Card width from CSS
    const hexRadius = cardWidth * 0.85; // Radius so images touch (slightly less for overlap)
    const hexAngle = (Math.PI * 2) / 6; // 60 degrees per vertex
    
    items.forEach((item, i) => {
      // Calculate position relative to active (center)
      let position = i - active;
      
      // Normalize position for infinite loop
      while (position > total / 2) {
        position -= total;
      }
      while (position < -total / 2) {
        position += total;
      }
      
      const abs = Math.abs(position);
      
      // Show only 6 images: center + 5 around it
      if (abs > 2.5) {
        item.style.opacity = 0;
        item.style.pointerEvents = 'none';
        item.style.zIndex = 0;
        return;
      }
      
      let translateX = 0;
      let translateY = 0;
      let translateZ = 0;
      let rotateY = 0;
      let rotateX = 0;
      let scale = 1;
      let opacity = 1;
      
      if (abs === 0) {
        // Center image - always fully visible, no opacity, no depth
        translateX = 0;
        translateY = 0;
        translateZ = 0;
        rotateY = 0;
        rotateX = 0;
        scale = 1;
        opacity = 1;
      } else {
        // Position images in hexagon around center, touching each other
        let hexPosition = position;
        if (hexPosition < 0) {
          hexPosition = 6 + hexPosition;
        }
        
        // Calculate angle for hexagon vertex (0-5, starting from top)
        const angle = hexPosition * hexAngle - Math.PI / 2;
        
        // Position so images touch (form continuous hexagon)
        translateX = Math.cos(angle) * hexRadius;
        translateY = Math.sin(angle) * hexRadius;
        
        // Depth effect - push back in 3D space
        translateZ = -abs * 180;
        
        // Rotate to face center and create depth
        rotateY = Math.atan2(translateX, -translateZ) * (180 / Math.PI);
        rotateX = Math.atan2(translateY, -translateZ) * (180 / Math.PI) * 0.3;
        
        scale = 0.75;
        opacity = 0.6; // Semi-transparent
      }
      
      // Hover effect - make hovered card fully visible and bring forward
      if (i === hoveredIndex && abs !== 0) {
        opacity = 1;
        scale = 0.85;
        translateZ = -abs * 100; // Bring forward on hover
      }
      
      item.style.opacity = opacity;
      item.style.pointerEvents = 'auto';
      item.style.zIndex = abs === 0 ? 10 : (10 - abs);
      
      item.style.transform = `
        translateX(${translateX}px)
        translateY(${translateY}px)
        translateZ(${translateZ}px)
        rotateY(${rotateY}deg)
        rotateX(${rotateX}deg)
        scale(${scale})
      `;
    });
  }

  function next() {
    target += 1;
  }

  function prev() {
    target -= 1;
  }

  // Normalize target to prevent extreme values (but allow infinite loop)
  function normalizeTarget() {
    while (target - active > total / 2) {
      target -= total;
      active -= total;
    }
    while (active - target > total / 2) {
      target += total;
      active += total;
    }
  }

  // Pause on hover
  const section = track.closest('section');
  if (section) {
    let isPaused = false;
    let autoplayTimer = null;

    function startAutoplay() {
      if (isPaused) return;
      stopAutoplay();
      autoplayTimer = setInterval(() => {
        next();
      }, 3000);
    }

    function stopAutoplay() {
      if (autoplayTimer) {
        clearInterval(autoplayTimer);
        autoplayTimer = null;
      }
    }

    section.addEventListener('mouseenter', () => {
      isPaused = true;
      stopAutoplay();
    });

    section.addEventListener('mouseleave', () => {
      isPaused = false;
      startAutoplay();
    });

    // Drag/swipe functionality
    let isDragging = false;
    let startX = 0;
    let startTarget = 0;
    let dragOffset = 0;

    function handleStart(e) {
      isDragging = true;
      startX = e.touches ? e.touches[0].clientX : e.clientX;
      startTarget = target;
      dragOffset = 0;
      stopAutoplay();
      e.preventDefault();
    }

    function handleMove(e) {
      if (!isDragging) return;
      
      const currentX = e.touches ? e.touches[0].clientX : e.clientX;
      dragOffset = startX - currentX;
      
      // Convert pixel drag to target offset (sensitivity for hexagon rotation)
      const slideOffset = dragOffset / 150;
      target = startTarget + slideOffset;
      
      e.preventDefault();
    }

    function handleEnd(e) {
      if (!isDragging) return;
      
      isDragging = false;
      
      // Snap to nearest slide based on drag distance
      const slideOffset = dragOffset / 150;
      if (Math.abs(slideOffset) > 0.3) {
        if (slideOffset > 0) {
          target = Math.ceil(startTarget + slideOffset);
        } else {
          target = Math.floor(startTarget + slideOffset);
        }
      } else {
        target = Math.round(startTarget + slideOffset);
      }
      
      normalizeTarget();
      
      // Resume autoplay after delay
      setTimeout(() => {
        if (!isPaused) {
          startAutoplay();
        }
      }, 2000);
    }

    // Mouse events
    track.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);
    window.addEventListener('mouseleave', handleEnd);

    // Touch events
    track.addEventListener('touchstart', handleStart, { passive: false });
    window.addEventListener('touchmove', handleMove, { passive: false });
    window.addEventListener('touchend', handleEnd);
    window.addEventListener('touchcancel', handleEnd);

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      const rect = section.getBoundingClientRect();
      if (rect.top < window.innerHeight && rect.bottom > 0) {
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          prev();
          stopAutoplay();
          setTimeout(startAutoplay, 2000);
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          next();
          stopAutoplay();
          setTimeout(startAutoplay, 2000);
        }
      }
    });

    // Hover functionality - make hovered card fully opaque
    items.forEach((item, i) => {
      item.addEventListener('mouseenter', () => {
        hoveredIndex = i;
      });
      item.addEventListener('mouseleave', () => {
        hoveredIndex = -1;
      });
    });

    // Start animation loop
    animate();
    startAutoplay();

    // Cleanup on section unload
    document.addEventListener('shopify:section:unload', function(e) {
      if (e.detail.sectionId === '{{ id }}') {
        isAnimating = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        stopAutoplay();
      }
    });
  } else {
    animate();
    setInterval(() => {
      next();
    }, 3000);
  }
})();
</script>

{% schema %}
{
  "name": "3D Arc Carousel",
  "tag": "section",
  "class": "section",
  "blocks": [
    {
      "type": "slide",
      "name": "Slide",
      "settings": [
        {
          "type": "image_picker",
          "id": "image",
          "label": "Image"
        }
      ]
    }
  ],
  "presets": [
    {
      "name": "3D Hexagon Carousel",
      "blocks": [
        {
          "type": "slide"
        },
        {
          "type": "slide"
        },
        {
          "type": "slide"
        },
        {
          "type": "slide"
        },
        {
          "type": "slide"
        },
        {
          "type": "slide"
        }
      ]
    }
  ]
}
{% endschema %}
