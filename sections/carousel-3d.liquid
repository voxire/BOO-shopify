{%- liquid
  assign id = section.id
  assign slides = section.blocks
-%}

<style>
.carousel-arc-{{ id }} {
  background: #fff;
  padding: 80px 0;
  overflow: hidden;
}

.carousel-arc-scene-{{ id }} {
  perspective: 1800px;
  perspective-origin: center center;
  display: flex;
  justify-content: center;
  transform-style: preserve-3d;
}

.carousel-arc-track-{{ id }} {
  position: relative;
  width: 420px;
  height: 560px;
  transform-style: preserve-3d;
  cursor: grab;
  user-select: none;
}

.carousel-arc-track-{{ id }}:active {
  cursor: grabbing;
}

.carousel-arc-item-{{ id }} {
  position: absolute;
  inset: 0;
  border-radius: 16px;
  overflow: hidden;
  transform-origin: center center;
  transition: opacity 0.3s ease;
  backface-visibility: hidden;
}

.carousel-arc-item-{{ id }} img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Mobile */
@media (max-width: 768px) {
  .carousel-arc-track-{{ id }} {
    width: 280px;
    height: 400px;
  }
}
</style>

<section class="carousel-arc-{{ id }}">
  <div class="carousel-arc-scene-{{ id }}">
    <div class="carousel-arc-track-{{ id }}" data-track>
      {%- for block in slides -%}
        <div
          class="carousel-arc-item-{{ id }}"
          data-index="{{ forloop.index0 }}">
          {%- if block.settings.image != blank -%}
            <img
              src="{{ block.settings.image | image_url: width: 1200 }}"
              alt="{{ block.settings.image.alt | escape }}"
              loading="lazy">
          {%- else -%}
            <div style="width: 100%; height: 100%; background: #f5f5f5; display: flex; align-items: center; justify-content: center; color: #999; border-radius: 16px;">
              {{ 'image' | placeholder_svg_tag: 'placeholder' }}
            </div>
          {%- endif -%}
        </div>
      {%- endfor -%}
    </div>
  </div>
</section>

<script>
(() => {
  const track = document.querySelector('[data-track]');
  if (!track) return;

  const items = [...track.children];
  const total = items.length;

  if (total === 0) return;

  // Floating active index for continuous interpolation
  let active = 0;
  let target = 0;

  // Animation loop
  let animationId = null;
  let isAnimating = true;

  function animate() {
    // Normalize target periodically to prevent extreme values
    normalizeTarget();
    
    // Interpolate active towards target
    active += (target - active) * 0.08;
    
    render();
    
    if (isAnimating) {
      animationId = requestAnimationFrame(animate);
    }
  }

  function render() {
    items.forEach((item, i) => {
      // Calculate floating diff with proper infinite loop wrapping
      let diff = i - active;
      
      // Normalize diff to [-total/2, total/2] range for infinite loop
      while (diff > total / 2) {
        diff -= total;
      }
      while (diff < -total / 2) {
        diff += total;
      }
      
      const abs = Math.abs(diff);

      // Visibility
      if (abs > 3.2) {
        item.style.opacity = 0;
        item.style.pointerEvents = 'none';
        item.style.zIndex = 0;
        return;
      }

      // Transform model (EXACT)
      const translateX = diff * 150;
      const translateZ = -abs * 260;
      const rotateY = diff * 14;
      const scale = Math.max(0.78, Math.min(1, 1 - abs * 0.08));

      // Z-index
      const zIndex = Math.round(100 - abs * 10);

      item.style.opacity = 1;
      item.style.pointerEvents = 'auto';
      item.style.zIndex = zIndex;

      item.style.transform = `
        translateX(${translateX}px)
        translateZ(${translateZ}px)
        rotateY(${rotateY}deg)
        scale(${scale})
      `;
    });
  }

  function next() {
    target += 1;
  }

  function prev() {
    target -= 1;
  }

  // Normalize target to prevent extreme values (but allow infinite loop)
  function normalizeTarget() {
    while (target - active > total / 2) {
      target -= total;
      active -= total;
    }
    while (active - target > total / 2) {
      target += total;
      active += total;
    }
  }

  // Pause on hover
  const section = track.closest('section');
  if (section) {
    let isPaused = false;
    let autoplayTimer = null;

    function startAutoplay() {
      if (isPaused) return;
      stopAutoplay();
      autoplayTimer = setInterval(() => {
        next();
      }, 3000);
    }

    function stopAutoplay() {
      if (autoplayTimer) {
        clearInterval(autoplayTimer);
        autoplayTimer = null;
      }
    }

    section.addEventListener('mouseenter', () => {
      isPaused = true;
      stopAutoplay();
    });

    section.addEventListener('mouseleave', () => {
      isPaused = false;
      startAutoplay();
    });

    // Drag/swipe functionality
    let isDragging = false;
    let startX = 0;
    let startTarget = 0;
    let dragOffset = 0;

    function handleStart(e) {
      isDragging = true;
      startX = e.touches ? e.touches[0].clientX : e.clientX;
      startTarget = target;
      dragOffset = 0;
      stopAutoplay();
      e.preventDefault();
    }

    function handleMove(e) {
      if (!isDragging) return;
      
      const currentX = e.touches ? e.touches[0].clientX : e.clientX;
      dragOffset = startX - currentX;
      
      // Convert pixel drag to target offset (150px per slide)
      const slideOffset = dragOffset / 150;
      target = startTarget + slideOffset;
      
      e.preventDefault();
    }

    function handleEnd(e) {
      if (!isDragging) return;
      
      isDragging = false;
      
      // Snap to nearest slide based on drag distance
      const slideOffset = dragOffset / 150;
      if (Math.abs(slideOffset) > 0.3) {
        if (slideOffset > 0) {
          target = Math.ceil(startTarget + slideOffset);
        } else {
          target = Math.floor(startTarget + slideOffset);
        }
      } else {
        target = Math.round(startTarget + slideOffset);
      }
      
      normalizeTarget();
      
      // Resume autoplay after delay
      setTimeout(() => {
        if (!isPaused) {
          startAutoplay();
        }
      }, 2000);
    }

    // Mouse events
    track.addEventListener('mousedown', handleStart);
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleEnd);
    window.addEventListener('mouseleave', handleEnd);

    // Touch events
    track.addEventListener('touchstart', handleStart, { passive: false });
    window.addEventListener('touchmove', handleMove, { passive: false });
    window.addEventListener('touchend', handleEnd);
    window.addEventListener('touchcancel', handleEnd);

    // Keyboard navigation
    document.addEventListener('keydown', (e) => {
      const rect = section.getBoundingClientRect();
      if (rect.top < window.innerHeight && rect.bottom > 0) {
        if (e.key === 'ArrowLeft') {
          e.preventDefault();
          prev();
          stopAutoplay();
          setTimeout(startAutoplay, 2000);
        } else if (e.key === 'ArrowRight') {
          e.preventDefault();
          next();
          stopAutoplay();
          setTimeout(startAutoplay, 2000);
        }
      }
    });

    // Start animation loop
    animate();
    startAutoplay();

    // Cleanup on section unload
    document.addEventListener('shopify:section:unload', function(e) {
      if (e.detail.sectionId === '{{ id }}') {
        isAnimating = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        stopAutoplay();
      }
    });
  } else {
    animate();
    setInterval(() => {
      next();
    }, 3000);
  }
})();
</script>

{% schema %}
{
  "name": "3D Arc Carousel",
  "tag": "section",
  "class": "section",
  "blocks": [
    {
      "type": "slide",
      "name": "Slide",
      "settings": [
        {
          "type": "image_picker",
          "id": "image",
          "label": "Image"
        }
      ]
    }
  ],
  "presets": [
    {
      "name": "3D Arc Carousel",
      "blocks": [
        {
          "type": "slide"
        },
        {
          "type": "slide"
        },
        {
          "type": "slide"
        },
        {
          "type": "slide"
        }
      ]
    }
  ]
}
{% endschema %}
